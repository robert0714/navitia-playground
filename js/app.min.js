// Copyright (c) 2016 CanalTP
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

'use strict';

// fake includes
var storage;
var summary;
var response;
var request;
var utils;

var autocomplete = {};

autocomplete._paramValueEverywhere = [
    'depth', 'count', 'forbidden_uris[]', 'filter', 'bss_stands'
];

autocomplete._collections = [
    'addresses', 'commercial_modes', 'companies', 'contributors', 'coord', 'coverage',
    'datasets', 'disruptions', 'lines', 'networks', 'places', 'poi_types', 'pois',
    'physical_modes', 'routes', 'stop_areas', 'stop_points', 'vehicle_journeys'
];

autocomplete._additionalFeatures = [
    'departures', 'journeys', 'places_nearby', 'pt_objects', 'route_schedules',
    'stop_schedules', 'arrivals', 'isochrones', 'heat_maps'
];

autocomplete._paramJourneyCommon = [
    'from', 'to', 'datetime','traveler_type', 'data_freshness',
    'first_section_mode[]', 'last_section_mode[]'
].concat(autocomplete._paramValueEverywhere);

autocomplete._depArrParams = [
    'from_datetime', 'duration', 'data_freshness'
].concat(autocomplete._paramValueEverywhere);

autocomplete._schedulesParams = [
    'from_datetime', 'duration', 'items_per_schedule', 'data_freshness'
].concat(autocomplete._paramValueEverywhere);

autocomplete._placesParams = [
    'q', 'type[]', 'admin_uri[]', 'from'
].concat(autocomplete._paramValueEverywhere);

autocomplete._fallbackMode = ['walking', 'car', 'bike', 'bss'];

autocomplete._booleanValues = ['true', 'false'];

autocomplete.autocompleteTree = {
    pathKey: {
        empty : ['coverage', 'places', 'coord'],
        all : autocomplete._collections,
    },
    features: {
        all: autocomplete._collections.concat(autocomplete._additionalFeatures),
    },
    paramKey: {
        arrivals: autocomplete._depArrParams,
        coord: autocomplete._paramValueEverywhere,
        coverage: autocomplete._paramValueEverywhere,
        departures: autocomplete._depArrParams,
        journeys: ['datetime_represents'].concat(autocomplete._paramJourneyCommon),
        isochrones: ['max_duration', 'min_duration', 'boundary_duration[]'].concat(autocomplete._paramJourneyCommon),
        heat_maps: ['max_duration', 'resolution'].concat(autocomplete._paramJourneyCommon),
        lines: autocomplete._paramValueEverywhere,
        places_nearby: autocomplete._placesParams,
        places: autocomplete._placesParams,
        pois: ['distance'].concat(autocomplete._paramValueEverywhere),
        pt_objects: ['q', 'type[]'].concat(autocomplete._paramValueEverywhere),
        stop_areas: autocomplete._paramValueEverywhere,
        stop_points: autocomplete._paramValueEverywhere,
        routes: autocomplete._paramValueEverywhere,
        route_schedules: autocomplete._schedulesParams,
        stop_schedules: autocomplete._schedulesParams,
        empty: autocomplete._paramValueEverywhere,
    },
    paramValue : {
        traveler_type : ['luggage', 'standard', 'fast_walker', 'slow_walker'],
        datetime_represents : ['arrival', 'departure'],
        data_freshness: ['base_schedule', 'adapted_schedule', 'realtime'],
        debug: autocomplete._booleanValues,
        wheelchair: autocomplete._booleanValues,
        disable_geojson: autocomplete._booleanValues,
        bss_stands: autocomplete._booleanValues,
        'first_section_mode[]': autocomplete._fallbackMode,
        'last_section_mode[]': autocomplete._fallbackMode,
    }
};

autocomplete.apiAutocomplete = function() {
    var input = $('#api input.api');
    var apis = storage.getApis();
    autocomplete._customAutocompleteHelper(input, apis, {
        close: request.setSaveTokenButtonStatus,
        select: function (event, ui) {
            $(input).val(ui.item.value);
            $('#token input.token').val(storage.getToken(ui.item.value));
        }
    });
};

autocomplete.valueAutoComplete = function (input, key) {
    if (utils.isDatetimeType(key)) {
        autocomplete._makeDatetime(input);
    } else if (key in this.autocompleteTree.paramValue){
        autocomplete._customAutocompleteHelper(input, this.autocompleteTree.paramValue[key]);
    } else if (this.staticAutocompleteTypes.indexOf(key) > -1) {
        this.staticAutocomplete(input, key);
    } else if (key in this.dynamicAutocompleteTypes) {
        this.dynamicAutocomplete(input, key);
    }
};

autocomplete.addKeyAutocomplete = function(input, type) {
    var source;
    if (type === 'pathKey' && ! $('#pathFrame').find('.value').length) {
        source = this.autocompleteTree[type].empty;
    } else if (type === 'paramKey'){
        var feature = $('#featureInput').val();
        source = this.autocompleteTree[type][feature] || this.autocompleteTree[type].empty;
    } else {
        source = this.autocompleteTree[type].all;
    }
    source = source || [];
    autocomplete._customAutocompleteHelper(input, source, {
        select: function(event, ui) { $(input).val(ui.item.value).change(); }
    });
};

autocomplete.staticAutocompleteTypes = [
    'coverage',
    'physical_modes',
    'poi_types',
];

autocomplete.staticAutocomplete = function(input, staticType) {
    var old_req = '';
    var old_token = '';
    var handle = function() {
        var api = $('#api input.api').val();
        var token = $('#token input.token').val();
        var cov = request.getCoverage();
        var req = api +  '/coverage/';
        if (staticType !== 'coverage') {
            req +=  cov + '/' + staticType;
        }
        req += '?disable_geojson=true';
        if (req !== old_req || token !== old_token) {
            old_req = req;
            old_token = token;
            autocomplete.updateStaticAutocomplete(input, staticType, req, token);
        } else if ($(input).is(':focus') && $(input).autocomplete('instance')) {
            $(input).autocomplete('search', '');
        }
    };
    handle();
    $(input).focus(handle);
};

autocomplete.updateStaticAutocomplete = function(input, staticType, req, token) {
    if ($(input).autocomplete('instance')) {
        // be shure that out-of-date autocompletion will not be active
        $(input).autocomplete('destroy');
    }
    $.ajax({
        headers: utils.manageToken(token),
        dataType: 'json',
        url: req,
        success: function(data) {
            var res = [];
            staticType = (staticType==='coverage') ? 'regions' :  staticType;
            data[staticType].forEach(function(elt) {
                var s = summary.run(new response.Context(data), utils.getType(staticType), elt);
                res.push({ value: elt.id, label: s.textContent, desc: s });
            });
            res = res.sort(function(a, b) {
                if (a.label < b.label) { return -1; }
                if (a.label > b.label) { return 1; }
                return 0;
            });
            $(input).autocomplete({
                close: function() { request.updateUrl($(input)[0]); },
                source: res,
                minLength: 0,
                scroll: true,
                delay: 0
            }).autocomplete('instance')._renderItem = function(ul, item) {
                return $('<li>').append(item.desc).appendTo(ul);
            };
            $(input).autocomplete('enable');
            if ($(input).is(':focus') && $(input).autocomplete('instance')) {
                $(input).autocomplete('search', '');
            }
        },
        error: function(data, status, error) {
            utils.notifyOnError('Autocomplete', req, data, status, error);
        }
    });
};

autocomplete.getUrlWithCov = function() {
    var url = $('#api input.api').val() + '/';
    var cov = request.getCoverage();
    url += cov ? ('coverage/' + cov) : '';
    return url;
};

autocomplete.AbstractObject = function(types) {
    this.types = types || [];
};
autocomplete.AbstractObject.prototype.autocompleteUrl = function(term) {
    var url = autocomplete.getUrlWithCov();
    url += '/' + this.api + '?display_geojson=false&q=' + encodeURIComponent(term);
    this.types.forEach(function(type) {
        url += '&type[]=' + type;
    });
    return url;
};
autocomplete.AbstractObject.prototype.objectUrl = function(term) {
    var url = autocomplete.getUrlWithCov();
    url += '/' + this.api + '/' + encodeURIComponent(term) + '?display_geojson=false';
    return url;
};
autocomplete.AbstractObject.prototype.source = function(urlMethod) {
    if (urlMethod === undefined) { urlMethod = 'autocompleteUrl'; }
    var self = this;
    return function(req, res) {
        var token = $('#token input.token').val();
        var url = self[urlMethod](req.term);
        if (! url) { return res([]); }
        $.ajax({
            url: url,
            headers: utils.manageToken(token),
            success: function (data) {
                var result = [];
                var key = response.responseCollectionName(data);
                var search = key ? data[key] : [];
                var type = utils.getType(key);
                if (search) {
                    search.forEach(function(s) {
                        var sum = summary.run(new response.Context(data), type, s);
                        result.push({ value: s.id, label: sum });
                    });
                }
                res(result);
            },
            error: function(data, status, error) {
                res([]);
                utils.notifyOnError('Autocomplete', url, data, status, error);
            }
        });
    };
};
autocomplete.AbstractObject.prototype.describe = function(elt) {
    $(elt).autocomplete('option', 'source', this.source('objectUrl'));
    $(elt).autocomplete('search');
    $(elt).autocomplete('option', 'source', this.source());
};

autocomplete.PtObject = function(types) {
    autocomplete.AbstractObject.call(this, types);
};
autocomplete.PtObject.prototype = Object.create(autocomplete.AbstractObject.prototype);
autocomplete.PtObject.prototype.api = 'pt_objects';
autocomplete.PtObject.prototype.objectUrl = function(term) {
    // /pt_objects/{pt_object.id} is not supported yet by navitia,
    // using the type if there is no ambiguity.
    if (this.types.length === 1) {
        var url = autocomplete.getUrlWithCov();
        url += '/' + this.types[0] + 's/' + encodeURIComponent(term) + '?display_geojson=false';
        return url;
    }
    return null;
};

autocomplete.Place = function(types) {
    autocomplete.AbstractObject.call(this, types);
};
autocomplete.Place.prototype = Object.create(autocomplete.AbstractObject.prototype);
autocomplete.Place.prototype.api = 'places';

autocomplete.dynamicAutocompleteTypes = {
    'addresses': new autocomplete.Place(['address']),
    'administrative_regions': new autocomplete.Place(['administrative_region']),
    'commercial_modes': new autocomplete.PtObject(['commercial_mode']),
    'coord': new autocomplete.Place(['address']),
    'forbidden_uris[]': new autocomplete.PtObject(),
    'lines': new autocomplete.PtObject(['line']),
    'networks': new autocomplete.PtObject(['network']),
    'places': new autocomplete.Place(),
    'pois': new autocomplete.Place(['poi']),
    'routes': new autocomplete.PtObject(['route']),
    'stop_areas': new autocomplete.Place(['stop_area']),
    'stop_points': new autocomplete.Place(['stop_point']),
    'from': new autocomplete.Place(),
    'to': new autocomplete.Place(),
};

autocomplete.dynamicAutocomplete = function (elt, dynamicType) {
    var object = autocomplete.dynamicAutocompleteTypes[dynamicType];
    $(elt).autocomplete({
        delay: 200,
        close: function() { request.updateUrl($(elt)[0]); },
        source: object.source()
    }).focus(function() {
        object.describe(this);
    }).hover(function() {
        if (! $(this).is(':focus')) { object.describe(this); }
    }, function() {
        if (! $(this).is(':focus')) { $(this).autocomplete('close'); }
    }).autocomplete('instance')._renderItem = function(ul, item) {
        return $('<li>').append(item.label).appendTo(ul);
    };
};

autocomplete._customAutocompleteHelper = function(input, source, customOptions) {
    if (source.length && source[0] instanceof Object) {
        source = source.sort(function(a, b) {
            if (a.value < b.value) { return -1; }
            if (a.value > b.value) { return 1; }
            return 0;
        });
    } else {
        source = source.sort();
    }
    var options = {
        close: function() { request.updateUrl($(input)[0]); },
        source: source,
        minLength: 0,
        scroll: true,
        delay: 0
    };
    if (customOptions) { $.extend(true, options, customOptions); }
    $(input).autocomplete(options).focus(function() {
        $(this).autocomplete('search', '');
    });
};

autocomplete._makeDatetime = function(elt) {
    $(elt).datetimepicker({
        dateFormat: 'yymmdd',
        timeFormat: 'HHmmss',
        timeInput: true,
        separator: 'T',
        controlType: 'select',
        oneLine: true,
    });
};

// Copyright (c) 2016 CanalTP
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

'use strict';

// fake includes
var response;
var summary;
var utils;

var extended = {};

// the object that contains the function to make the extended views
extended.make = {};

extended.make.response = function(context, json) {
    var result = $('<div class="list"/>');

    if ('full_response' in json) {
        result.append(response.render(context, json.full_response, 'response', 'full_response'));
    }

    if (Array.isArray(json.links) && json.links.length) {
        result.append(response.render(context, json.links, 'links', 'links'));
    }

    var key = response.responseCollectionName(json);
    var objs = key ? json[key] : [];
    var type = utils.getType(key);
    if (type) {
        objs.forEach(function(obj, i) {
            result.append(response.render(context, obj, type, key, i));
        });
    }

    if (type !== 'disruption' && $.isArray(json.disruptions)) {
        json.disruptions.forEach(function(disruption, i) {
            result.append(response.render(context, disruption, 'disruption', 'disruptions', i));
        });
    }

    if ($.isArray(json.feed_publishers)) {
        json.feed_publishers.forEach(function(feed_publisher, i) {
            result.append(response.render(context, feed_publisher, 'contributor', 'feed_publishers', i));
        });
    }

    if ('warnings' in json) {
        json.warnings.forEach(function(warning, i) {
            result.append(response.render(context, warning, 'warning', 'warnings', i));
        });
    }
    return result;
};

extended.make.journey = function(context, json) {
    var result = $('<div class="list"/>');
    if ('tags' in json && json.tags.length > 0) {
        result.append(response.render(context, json.tags, 'tags', 'tags'));
    }
    if (json.co2_emission && json.co2_emission.value) {
        result.append(response.render(context, json.co2_emission, 'co2_emission', 'co2_emission'));
    }
    json.sections.forEach(function(section, i) {
        result.append(response.render(context, section, 'section', 'sections', i));
    });
    return result;
};

extended.make.section = function(context, json) {
    var result = $('<div class="list"/>');
    if (Array.isArray(json.links) && json.links.length) {
        result.append(response.render(context, json.links, 'links', 'links'));
    }
    if (json.from) {
        result.append(response.render(context, json.from, 'place', 'from'));
    }
    if (json.to) {
        result.append(response.render(context, json.to, 'place', 'to'));
    }
    if (json.co2_emission && json.co2_emission.value) {
        result.append(response.render(context, json.co2_emission, 'co2_emission', 'co2_emission'));
    }
    if (json.stop_date_times) {
        json.stop_date_times.forEach(function(stop_date_time, i) {
            result.append(response.render(context, stop_date_time, 'stop_date_time', 'stop_date_times', i));
        });
    }
    return result;
};

extended.make.stop_schedule = function(context, json) {
    var result = $('<div class="list"/>');
    if (Array.isArray(json.links) && json.links.length) {
        result.append(response.render(context, json.links, 'links', 'links'));
    }
    json.date_times.forEach(function(date_time, i) {
        result.append(response.render(context, date_time, 'date_time', 'date_times', i));
    });
    return result;
};

extended.make.route_schedule = function(context, json) {
    var result = $('<div class="list"/>');
    if (Array.isArray(json.links) && json.links.length) {
        result.append(response.render(context, json.links, 'links', 'links'));
    }
    result.append(response.render(context, json.table, 'table', 'table'));
    return result;
};

extended.make.table = function(context, json) {
    var result = $('<div class="table"/>');
    var table = $('<table/>');
    // Add the data rows
    json.rows.forEach(function(route_schedule) {
        var row = $('<tr/>');
        var cellName = $('<td />').addClass('stop-point');
        cellName.text(route_schedule.stop_point.name);
        row.append(cellName);
        route_schedule.date_times.forEach(function(route_schedule) {
            var cellValue = $('<td />').addClass('time');
            cellValue.html(summary.formatTime(route_schedule.date_time));
            row.append(cellValue);
        });
        table.append(row);
    });
    result.append(table);
    return result;
};

extended.make.poi = function(context, json) {
    var result = extended.defaultExtended(context, 'poi', json);
    if (json.stands) {
        result.append(response.render(context, json.stands, 'stands', 'stands'));
    }
    return result;
};

extended.make.disruption = function(context, json) {
    var res = $('<div class="list"/>');
    if (json.application_periods) {
        res.append(response.render(context,
                                   json.application_periods,
                                   'application_periods',
                                   'application_periods'));
    }
    if (json.messages) {
        json.messages.forEach(function(obj, i) {
            res.append(response.render(context, obj, 'message', 'messages', i));
        });
    }
    json.impacted_objects.forEach(function(obj, i) {
        res.append(response.render(context, obj, 'impacted_object', 'impacted_objects', i));
    });
    return res;
};

extended.make.impacted_object = function(context, json) {
    var res = $('<div class="list"/>');
    res.append(response.render(context, json.pt_object, 'pt_object', 'pt_object'));
    if ($.isArray(json.impacted_stops)) {
        json.impacted_stops.forEach(function(obj, i) {
            res.append(response.render(context, obj, 'impacted_stop', 'impacted_stops', i));
        });
    }
    return res;
};

extended.make.connection = function(context, json) {
    return $('<div class="list"/>')
        .append(response.render(context, json.origin, 'stop_point', 'origin'))
        .append(response.render(context, json.destination, 'stop_point', 'destination'));
};

// add your extended view by addind:
//   extended.make.{type} = function(context, json) { ... }

extended.defaultExtended = function(context, type, json) {
    var result = $('<div class="list"/>');
    if (Array.isArray(json.links) && json.links.length) {
        result.append(response.render(context, json.links, 'links', 'links'));
    }
    if (Array.isArray(json.codes) && json.codes.length) {
        result.append(response.render(context, json.codes, 'codes', 'codes'));
    }
    for (var key in json) {
        if (! (utils.getType(key) in context.links)) { continue; }
        if ($.isArray(json[key])) {
            json[key].forEach(function(obj, i) {
                result.append(response.render(context, obj, utils.getType(key), key, i));
            });
        } else {
            result.append(response.render(context, json[key], utils.getType(key), key));
        }
    }
    return result;
};

extended.has = {};
extended.has.journey = function(context, type, json) {
    return Boolean(json.sections);
};
extended.has.section = function(context, type, json) {
    return Boolean(json.from) || Boolean(json.to) || Boolean(json.stop_date_times);
};
extended.has.poi = function(context, type, json) {
    return extended.hasDefaultExtended(context, type, json);
};
extended.hasDefaultExtended = function(context, type, json) {
    if (! (json instanceof Object)) { return false; }
    if (Array.isArray(json.links) && json.links.length) { return true; }
    if (Array.isArray(json.codes) && json.codes.length) { return true; }
    for (var key in json) {
        if (utils.getType(key) in context.links) { return true; }
    }
    return false;
};

extended.hasExtended = function(context, type, json) {
    try {
        if (type in extended.make) {
            if (type in extended.has) {
                return extended.has[type](context, type, json);
            }
            return true;
        }
        return extended.hasDefaultExtended(context, type, json);
    } catch (e) {
        console.log(sprintf('hasExtended(%s) thows an exception:', type));// jshint ignore:line
        console.log(e);// jshint ignore:line
    }
    return false;
};

// main method
extended.run = function(context, type, json) {
    try {
        if (type in this.make) { return this.make[type](context, json); }
        return extended.defaultExtended(context, type, json);
    } catch (e) {
        console.log(sprintf('extended(%s) thows an exception:', type));// jshint ignore:line
        console.log(e);// jshint ignore:line
        return 'Error in extended view construction';
    }
};

// Copyright (c) 2016 CanalTP
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

'use strict';

// fake includes
var response;
var storage;
var summary;
var utils;

var map = {};

map.DrawSectionOption = {
    DRAWSTART: 2, // 10
    DRAWEND: 1, // 01
    DRAWBOTH: 3, // 11
    DRAWNEITHER: 0 // 00
};
map._should_draw_section_start = function(option) {
    return option & 2;// jshint ignore:line
};
map._should_draw_section_end = function(option) {
    return option & 1;// jshint ignore:line
};
map.STARTTEXT = 'Start';
map.ENDTEXT = 'End';
map.makeFeatures = {
    region: function(context, json) {
        if (json.shape) {
            var geoJsonShape = wkt2geojson(json.shape);
            return map._makePolygon(context, 'region', geoJsonShape, json, '#008ACA');
        }
        return [];
    },
    section: function(context, json, draw_section_option) {
        var color = json.display_informations;
        switch (json.type) {
        case 'street_network':
            switch (json.mode) {
            case 'bike': color = map.bikeColor; break;
            case 'car': color = map.carColor; break;
            case 'walking': color = map.walkingColor; break;
            }
            break;
        case 'transfer':
            switch (json.transfer_type) {
            case 'guaranteed': color = map.carColor; break;
            case 'extension': color = map.bikeColor; break;
            case 'walking': color = map.walkingColor; break;
            }
            break;
        case 'crow_fly': color = map.crowFlyColor; break;
        }
        if (draw_section_option === undefined) {
            draw_section_option = map.DrawSectionOption.DRAWBOTH;
        }
        return map._makeString(context, 'section', json, color)
            .concat(map._makeStopTimesMarker(context, json, color, draw_section_option));
    },
    line: function(context, json) {
        return map._makeString(context, 'line', json, json);
    },
    journey: function(context, json) {
        if (! ('sections' in json)) { return []; }
        var bind = function(s, i, array) {
            var draw_section_option = map.DrawSectionOption.DRAWNEITHER;
            if ( i === 0) {
                draw_section_option |= map.DrawSectionOption.DRAWSTART;// jshint ignore:line
            }
            if ( i === (array.length -1) ) {
                draw_section_option |= map.DrawSectionOption.DRAWEND;// jshint ignore:line
            }
            return map.makeFeatures.section(context, s, draw_section_option);
        };
        return utils.flatMap(json.sections, bind);
    },
    isochrone: function(context, json) {
        if (! ('geojson' in json)) { return []; }
        var color = context.getColorFromMinDuration(json.min_duration);
        var draw_section_option = map.DrawSectionOption.DRAWBOTH;
        var color_marker = '#000000';
        return map._makePolygon(context, 'isochrone', json.geojson, json, color)
            .concat(map._makeStopTimesMarker(context, json, color_marker, draw_section_option));
    },
    heat_map: function(context, json) {
        if (! ('heat_matrix' in json)) { return []; }
        var scale = 0;
        json.heat_matrix.lines.forEach(function(lines) {
            lines.duration.forEach(function(duration) {
                if (duration !== null) {
                    scale = Math.max(duration, scale);
                }
            });
        });
        var local_map = [];
        json.heat_matrix.lines.forEach(function(lines/*, i*/) {
            lines.duration.forEach(function(duration, j) {
                var color;
                if (duration !== null) {
                    var ratio = duration / scale;
                    color = utils.getColorFromRatio(ratio);
                } else {
                    color = '#000000';
                    // for the moment, we don't want to print the null duration squares because
                    // it impacts the performances of the navigator.
                    return;
                }
                var rectangle = [
                    [json.heat_matrix.line_headers[j].cell_lat.max_lat, lines.cell_lon.max_lon],
                    [json.heat_matrix.line_headers[j].cell_lat.min_lat, lines.cell_lon.min_lon]
                ];
                local_map.push(map._makePixel(context, 'heat_map', rectangle, json, color, duration));
            });
        });
        var draw_section_option = map.DrawSectionOption.DRAWBOTH;
        var color_marker = '#000000';
        return local_map.concat(map._makeStopTimesMarker(context, json, color_marker, draw_section_option));
    },
    address: function(context, json) {
        return map._makeMarker(context, 'address', json);
    },
    administrative_region: function(context, json) {
        return map._makeMarker('administrative_region', json);
    },
    stop_area: function(context, json) {
        return map._makeMarker(context, 'stop_area', json);
    },
    stop_point: function(context, json) {
        return map._makeMarker(context, 'stop_point', json);
    },
    place: function(context, json) {
        return map._makeMarker(context, 'place', json);
    },
    pt_object: function(context, json) {
        return map.getFeatures(context, json.embedded_type, json[json.embedded_type]);
    },
    poi: function(context, json) {
        return map._makeMarker(context, 'poi', json);
    },
    connection: function(context, json) {
        return utils.flatMap([json.origin, json.destination], function(json) {
            return map._makeMarker(context, 'stop_point', json);
        });
    },
    response: function(context, json) {
        var key = response.responseCollectionName(json);
        if (key === null) {
            return [];
        }
        var type = utils.getType(key);
        if (!(type in map.makeFeatures)) {
            return [];
        }
        var bind = function(s) {
            return map.makeFeatures[type](context, s);
        };
        return utils.flatMap(json[key].slice().reverse(), bind);
    }
};

map.hasMap = function(context, type, json) {
    return map.getFeatures(context, type, json).length !== 0;
};

map.getFeatures = function(context, type, json) {
    if (! (map.makeFeatures[type] instanceof Function)) { return []; }
    if (! (json instanceof Object)) { return []; }
    try {
        return map.makeFeatures[type](context, json);
    } catch (e) {
        console.log(sprintf('map.makeFeatures[%s] thows an exception:', type));// jshint ignore:line
        console.log(e);// jshint ignore:line
        return [];
    }
};

map._makeTileLayers = function() {
    var copyOSM = '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>';
    var courtesy = function(name) {
        return sprintf('%s & %s', copyOSM, name);
    };
    var makeStamenTileLayer = function(name) {
        return L.tileLayer('http://stamen-tiles-{s}.a.ssl.fastly.net/' + name + '/{z}/{x}/{y}.png', {
            subdomains: 'abcd',
            attribution: courtesy('<a href="http://maps.stamen.com">Stamen Design</a>'),
            detectRetina: true
        });
    };
    return {
        'Bright': L.tileLayer('http://tile-{s}.navitia.io/osm_bright/{z}/{x}/{y}.png', {
            attribution: courtesy('<a href="https://www.navitia.io/">navitia</a>'),
            detectRetina: true
        }),
        'HOT': L.tileLayer('http://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: courtesy('<a href="http://hot.openstreetmap.org/">Humanitarian OpenStreetMap Team</a>'),
            detectRetina: true
        }),
        'Hydda': L.tileLayer('https://{s}.tile.openstreetmap.se/hydda/full/{z}/{x}/{y}.png', {
            attribution: courtesy('<a href="http://openstreetmap.se/">OpenStreetMap Sweden</a>'),
            detectRetina: true
        }),
        'Mapnik': L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: copyOSM,
            detectRetina: true
        }),
        'Terrain': makeStamenTileLayer('terrain'),
        'Toner': makeStamenTileLayer('toner-lite'),
        'Watercolor': makeStamenTileLayer('watercolor'),
    };
};

map._getDefaultLayerName = function() {
    var saved = storage.getLayer();
    if (saved) { return saved; }
    return 'Hydda';
};

map.run = function(context, type, json) {
    var div = $('<div/>');
    // setting for default path of images used by leaflet
    L.Icon.Default.imagePath = 'lib/img/leaflet/dist/images/';
    var features = [];
    if ((features = map.getFeatures(context, type, json)).length) {
        div.addClass('leaflet');
        var m = L.map(div.get(0), {renderer: L.canvas()});
        var tileLayers = map._makeTileLayers();
        tileLayers[map._getDefaultLayerName()].addTo(m);
        L.control.layers(tileLayers).addTo(m);
        m.on('baselayerchange', storage.saveLayer);
        L.control.scale().addTo(m);
        var overlay = L.featureGroup(features).addTo(m);
        setTimeout(function() {
            m.invalidateSize();
            m.fitBounds(overlay.getBounds());
        }, 100);
    } else {
        div.addClass('noMap');
        div.append('No map');
    }
    return div;
};

map._makeMarker = function(context, type, json, colorJson, useCustomMarker, label) {
    var lat, lon;
    var obj = json;
    switch (type){
    case 'stop_date_time':
        obj = json.stop_point;
        lat = obj.coord.lat;
        lon = obj.coord.lon;
        break;
    case 'place':
        lat = json[json.embedded_type].coord.lat;
        lon = json[json.embedded_type].coord.lon;
        break;
    default:
        lat = json.coord.lat;
        lon = json.coord.lon;
    }
    var sum = summary.run(context, type, json);
    var t = type === 'place' ? json.embedded_type : type;
    var marker;
    if (! useCustomMarker) {
        marker = L.marker([lat, lon]);
    } else {
        var color = '#000000';
        if (colorJson  && colorJson instanceof Object && colorJson.color) {
            color = '#' + colorJson.color;
        }
        marker = L.circleMarker([lat, lon], {color: color, opacity: 1, fillColor: 'white', fillOpacity: 1});
        marker.setRadius(5);
    }
    if (label) {
        marker.bindTooltip(label, {permanent: true, opacity: 1});
    }
    return [marker.bindPopup(map._makeLink(context, t, obj, sum)[0])];
};

map.bikeColor = { color: 'CED480' };
map.carColor = { color: 'EFBF8F' };
map.walkingColor = { color: '89C6E5' };
map.crowFlyColor = { color: 'CBB6E4' };

map._getCoordFromPlace = function(place) {
    if (place && place[place.embedded_type] && place[place.embedded_type].coord) {
        return place[place.embedded_type].coord;
    }
    return null;
};

map._makeString = function(context, type, json, colorJson) {
    if (! (colorJson instanceof Object) || ! (colorJson.color)) {
        colorJson = { color: '000000' };
    }
    var sum = summary.run(context, type, json);
    var from = map._getCoordFromPlace(json.from);
    var to = map._getCoordFromPlace(json.to);
    var style1 = {
        color: utils.getTextColor(colorJson),
        weight: 6,
        opacity: 1
    };
    var style2 = {
        color: '#' + colorJson.color,
        weight: 5,
        opacity: 1
    };
    if (json.geojson && json.geojson.coordinates.length) {
        return [
            L.geoJson(json.geojson, { style: style1 }),
            L.geoJson(json.geojson, { style: style2 }).bindPopup(sum)
        ];
    } else if (from && to) {
        return [
            L.polyline([from, to], style1),
            L.polyline([from, to], style2).bindPopup(sum)
        ];
    } else {
        return [];
    }
};

map._makeStopTimesMarker = function(context, json, color, draw_section_option) {
    var stopTimes = json.stop_date_times;
    var markers = [];
    if (stopTimes) {
        // when section is PT
        stopTimes.forEach(function(st, i) {
            var label = null;
            if (i === 0 &&
                map._should_draw_section_start(draw_section_option)) {
                label = map.STARTTEXT;
            }else if (i === (stopTimes.length -1 ) &&
                      map._should_draw_section_end(draw_section_option)) {
                label = map.ENDTEXT;
            }
            markers = markers.concat(map._makeMarker(context, 'stop_date_time', st, color, true, label));
        });
    } else {
        // when section is Walking
        var from = json.from;
        var to = json.to;
        var label_from = null;
        var label_to = null;
        if (from && map._should_draw_section_start(draw_section_option)) {
            label_from = map.STARTTEXT;
            markers.push(map._makeMarker(context, 'place', from, color, true, label_from)[0]);
        }
        if (to && map._should_draw_section_end(draw_section_option)) {
            label_to = map.ENDTEXT;
            markers.push(map._makeMarker(context, 'place', to, color, true, label_to)[0]);
        }
    }
    return markers;
};
map._makePolygon = function(context, type, geoJsonCoords, json, color) {
    var sum = summary.run(context, type, json);
    // TODO use link when navitia has debugged the ticket NAVITIAII-2133
    var link = map._makeLink(context, type, json, sum)[0];
    return [
        L.geoJson(geoJsonCoords, {
            color:  '#555555',
            opacity: 1,
            weight: 0.5,
            fillColor: color,
            fillOpacity: 0.25
        }).bindPopup(link)
    ];
};
map._makeLink = function(context, type, obj, name) {
    return context.makeLink(type, obj, name);
};
map._makePixel = function(context, type, PolygonCoords, json, color, duration) {
    var sum = 'not accessible';
    if (duration !== null) {
        sum = sprintf('duration: %s', utils.durationToString(duration));
    }
    return L.rectangle(PolygonCoords, {
        smoothFactor: 0,
        color:  '#555555',
        opacity: 0,
        weight: 0,
        fillColor: color,
        fillOpacity: 0.25
    }).bindPopup(sum);
};

// Copyright (c) 2016 CanalTP
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

'use strict';

var modes = {};

modes.makePtPicto = function(json) {
    if ($.isArray(json)) {
        var res = $('<span/>');
        json.forEach(function(elt) {
            res.append(modes.makePtPicto(elt));
        });
        return res;
    }

    if (!(json instanceof Object) || !('id' in json)) {
        return $('<span/>');
    }
    var img = 'Unknown';
    switch (json.id) {
    case 'physical_mode:Air': img = 'Air'; break;
    case 'physical_mode:Bike': img = 'Bike'; break;
    case 'physical_mode:BikeSharingService': img = 'BikeSharingService'; break;
    case 'physical_mode:Car': img = 'Car'; break;
    case 'physical_mode:Coach': img = 'Coach'; break;
    case 'physical_mode:Funicular': img = 'Funicular'; break;
    case 'physical_mode:Metro': img = 'Metro'; break;
    case 'physical_mode:Taxi': img = 'Taxi'; break;
    case 'physical_mode:Tramway': img = 'Tramway'; break;
    case 'physical_mode:Walking': img = 'Walking'; break;
    case 'physical_mode:CheckIn': img = 'CheckIn'; break;
    case 'physical_mode:CheckOut': img = 'CheckOut'; break;
    case 'physical_mode:Shuttle': img = 'Shuttle'; break;

    case 'physical_mode:Bus':
    case 'physical_mode:BusRapidTransit':
    case 'physical_mode:Trolleybus':
        img = 'Bus'; break;

    case 'physical_mode:RapidTransit':
    case 'physical_mode:LocalTrain':
    case 'physical_mode:LongDistanceTrain':
    case 'physical_mode:Train':
        img = 'Train'; break;

    case 'physical_mode:Boat':
    case 'physical_mode:Ferry':
        img = 'Boat'; break;

    default:
        break;
    }

    return modes.makeImg(img, json.name);
};

modes.makeImg = function(img, name) {
    var tag = $('<img/>')
        .addClass('picto')
        .attr('src', sprintf('img/modes/%s.svg', img));
    if (name) { tag.attr('alt', name); }
    return tag;
};

modes.makeSnPicto = function(mode) {
    var img = 'Unknown';
    if (mode === 'walking') {
        img = 'Walking';
    } else if (mode === 'bike') {
        img = 'Bike';
    } else if (mode.indexOf('bss') === 0) {
        img = 'BikeSharingService';
    } else if (mode === 'car' || mode === 'park' || mode === 'leave_parking') {
        img = 'Car';
    }
    return modes.makeImg(img, mode);
};

// Copyright (c) 2016 CanalTP
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

'use strict';

// fake includes
var storage;
var autocomplete;
var utils;

var request = {};

request.setSaveTokenButtonStatus = function() {
    var api = $('#api input.api').val();
    var token = $('#token input.token').val();
    $('button.save').prop('disabled', storage.getToken(api) === token);
};

request.updateAddPathAC = function(val){
    var input = $(val).prev();
    if (! input.hasClass('path')) {
        return;
    }
    if (! $('input path').length) {
        // No more path inputs, we should update autocomplete of add
        autocomplete.addKeyAutocomplete($('#addPathInput'), 'pathKey');
    }
};

request.getFocusedElemValue = function(elemToTest, focusedElem, noEncoding) {
    var value = $(elemToTest).is('input') ? elemToTest.value : $(elemToTest).text();
    if (! noEncoding) { value = encodeURIComponent(value); }
    if (focusedElem === elemToTest) {
        return sprintf('<span class="focusedParam">%s</span>', value);
    } else {
        return value;
    }
};

request.finalUrl = function(focusedElem) {
    var api = request.getFocusedElemValue($('#api input.api')[0], focusedElem, true);
    if (api.slice(-1) === '/') { api = api.slice(0, -1); }

    var path = '';
    $('#path .key, #path input.value').each(function(){
        path += '/' + request.getFocusedElemValue(this, focusedElem);
    });
    var feature = request.getFocusedElemValue($('#featureInput')[0], focusedElem);

    var parameters = '?';
    $('#parameters .key, #parameters input.value').each(function(){
        parameters += request.getFocusedElemValue(this, focusedElem);
        if ($(this).hasClass('key')) {
            parameters += '=';
        }
        if ($(this).hasClass('value')) {
            parameters += '&';
        }
    });

    if (focusedElem === undefined) {
        // called without arg, we want pure text
        return api + path + '/' + feature + parameters;
    } else {
        // with arg, we want a rendering thing
        return sprintf('<span class="api">%s</span>' +
                       '<span class="path">%s</span>' +
                       '<span class="feature">/%s</span>' +
                       '<span class="parameters">%s</span>',
                       api, path, feature, parameters);
    }
};

request.updateUrl = function(focusedElem) {
    var link = request.finalUrl();
    var text = request.finalUrl(focusedElem);
    $('#requestUrl').html($('<a/>').attr('href', link).html(text));
};

request.makeDeleteButton = function() {
    return $('<button/>')
        .addClass('delete')
        .click(function() {
            $(this).closest('.toDelete').remove();
            request.updateAddPathAC(this);
            request.updateUrl(this);
        })
        .html('<img src="img/delete.svg" class="deleteButton" alt="delete">');
};

request.makeTemplatePath = function(val, input) {
    var templateFilled = false;
    var isTemplateFilled = function() {
        var curVal = input.val();
        if (! templateFilled && curVal !== val && curVal !== '') {
            input.closest('.inputDiv').removeClass('templateInput');
            templateFilled = true;
        }
        return templateFilled;
    };
    input.closest('.inputDiv').addClass('templateInput');
    input.focus(function() {
        if (! isTemplateFilled()) { this.value = ''; }
    }).blur(function() {
        if (! isTemplateFilled()) { this.value = val; }
    });
};

request.makeKeyValue = function(key, val, cls) {
    var res = $('<div/>')
        .addClass('inputDiv')
        .addClass('toDelete')
        .append(' ');

    res.append($('<span/>').addClass('key').text(key));

    var valueElt = $('<input/>')
         .attr('type', 'text')
         .attr('placeholder', 'type your value here')
        .addClass('value')
        .addClass(cls)
        .focus(function() { this.select(); })
        .val(val);

    autocomplete.valueAutoComplete(valueElt, key);

    valueElt.on('input', function() { request.updateUrl(this); });
    valueElt.focus(function() { request.updateUrl(this); });
    res.append(valueElt);
    res.append(request.makeDeleteButton());

    // valueElt must be attached to res to call this
    if (utils.isTemplate(val)) { request.makeTemplatePath(val, valueElt); }

    return res;
};

request.insertPathElt = function() {
    var key = $('#addPathInput').val();
    $('#addPathElt').before(request.makeKeyValue(key, '', 'path'));
    autocomplete.addKeyAutocomplete($('#addPathInput'), 'pathKey');
    $('#addPathInput').val('').change();
    $('#addPathElt').prev().find('input').first().focus();
};

request.insertParam = function() {
    var key = $('#addParamInput').val();
    $('#addParam').before(request.makeKeyValue(key, '', 'parameters'));
    $('#addParamInput').val('').change();
    $('#addParam').prev().find('input').first().focus();
};

request.updateAddParamAC = function() {
    autocomplete.addKeyAutocomplete($('#addParamInput'), 'paramKey');
};

request.submit = function() {
    var token = $('#token input.token').val();
    var f = request.finalUrl();
    window.location = sprintf('?request=%s&token=%s', encodeURIComponent(f), encodeURIComponent(token));
};

request.getCoverage = function() {
    var prevIsCoverage = false;
    var coverage = null;
    $('#path .key, #path input.value').each(function() {
        if (prevIsCoverage) {
            coverage = $(this).val();
        }
        prevIsCoverage = $(this).text() === 'coverage';
    });
    return coverage;
};

request.parseUrl = function() {
    var search = new URI(window.location).search(true);
    var req = search.request;
    if (req === undefined) { return null; }

    var req_uri = new URI(req);
    var api = req_uri.origin();
    var paths = req_uri.path().split('/');
    paths = paths.length === 1 ? [] : paths.slice(1);
    var api_path = [];

    var vxxFound = false;
    paths.forEach(function(r) {
        if (vxxFound) {
            api_path.push(decodeURIComponent(r));
        } else {
            api += '/' + decodeURIComponent(r);
            vxxFound = /^v\d+$/.test(r);
        }
    });
    if (! vxxFound) {
        api = req_uri.origin();
        api_path = paths.map(decodeURIComponent);
        utils.notifyWarn('Version not found in the URL. Maybe you forgot "/v1" at the end of the API?');
    }

    var params = req_uri.search(true);

    var token = search.token;

    if (token === undefined) {
        if (req_uri.username()) {
            token = req_uri.username();
            api = new URI(api).username('').toString();
        } else { token = storage.getToken(api); }
    }

    return {
        token: token,
        request: req,
        api: api,
        path: api_path,
        query: params === undefined ? {} : params
    };
};

request.setAutocomplete = function(){
    autocomplete.addKeyAutocomplete($('#featureInput'), 'features');
    autocomplete.addKeyAutocomplete($('#addPathInput'), 'pathKey');
    autocomplete.addKeyAutocomplete($('#addParamInput'), 'paramKey');
    autocomplete.apiAutocomplete();
};

request.manage = function() {
    // save token
    request.setSaveTokenButtonStatus();
    $('input.token')
        .change(request.setSaveTokenButtonStatus)
        .on('input', request.setSaveTokenButtonStatus);

    // hidden token management
    $('input.token').focusin(function() { $(this).attr('type', 'text'); })
        .focusout(function() { $(this).attr('type', 'password'); });

    // Manage add input/button
    $('button.add').prop('disabled', true);
    $('.addInput').on('input change', function() {
        $(this).parent().find('button.add').prop('disabled', this.value.length === 0);
    });
    $('.addInput').keyup(function(event) {
        if (event.keyCode === 13) {
            $(this).parent().find('button.add').click();
        }
    });
    $('#featureInput').focusout(request.updateAddParamAC);

    $('#request input').focus(function() { this.select(); });

    var req = request.parseUrl();

    if (req === null) {
        request.setAutocomplete();
        return;
    }

    if (req.token === undefined) { req.token = ''; }
    $('#token input.token').attr('value', req.token);
    $('#api input.api').attr('value', req.api);
    request.setSaveTokenButtonStatus();

    var prevPathElt = null;
    req.path.forEach(function(r) {
        if (prevPathElt === null) {
            prevPathElt = r;
        } else {
            $('#addPathElt').before(request.makeKeyValue(prevPathElt, r, 'path'));
            prevPathElt = null;
        }
    });
    if (prevPathElt !== null) {
        $('#featureInput').val(prevPathElt);
    }

    var addParam = $('#addParam');
    for (var key in req.query) {
        if (! req.query.hasOwnProperty(key)) { continue; }
        var value = req.query[key];
        // a list of params, ex.: forbidded_uris[]
        if (Array.isArray(value)) {
            value.forEach(function(v){
                addParam.before(request.makeKeyValue(decodeURIComponent(key), decodeURIComponent(v), 'parameters'));
            });
        } else {
            addParam.before(request.makeKeyValue(decodeURIComponent(key), decodeURIComponent(value), 'parameters'));
        }
    }
    request.setAutocomplete();
    request.updateUrl(null);
    $(document).keydown(function(event) {
        // control+enter, or option+enter on OS X
        if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {
            request.submit();
        }
    });
};

// Copyright (c) 2016 CanalTP
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

'use strict';

// fake includes
var summary;
var extended;
var map;
var storage;
var autocomplete;
var utils;
var request;

var response = {};

response.setStatus = function(message, status, start_time) {
    var res = $('<span/>').text('Status: ').append(message);
    res.append(utils.htmlEncode(sprintf(' (%s)', status)));
    if (typeof start_time === 'number') {
        var duration = new Date().getTime() - start_time;
        res.append(sprintf(', duration of the request: %dms', duration));
    }
    $('#status').html(res);
};

response.responseCollectionName = function(json) {
    if (! (json instanceof Object)) { return null; }
    var key = null;
    var notCollectionKeys = ['disruptions', 'links', 'feed_publishers', 'exceptions', 'notes', 'warnings'];
    for (var k in json) {
        if ($.isArray(json[k]) &&
            $.inArray(k, notCollectionKeys) === -1) {
            key = k;
        }
    }
    // disruptions may be an object list only if there is no other object list
    if (key === null && 'disruptions' in json) {
        key = 'disruptions';
    }
    return key;
};

response.makeObjectButton = function(name, handle) {
    // TODO call handle on toggle
    return $('<label>')
        .addClass('objectButton')
        .append($('<input type="checkbox">').change(handle))
        .append($('<span>').html(name));
};

response.makeObjectButtonHandle = function(selector, renderHandle) {
    return function() {
        var div = $(this).closest('div.object').children('div.data').children(selector);
        if ($(this).is(':checked')) {
            div.hide();
            div.html(renderHandle());
            div.slideDown(600);
            if (! $(this).hasClass('noAnimation')) {
                $('html, body').animate({ scrollTop: div.offset().top }, 600);
            }
        } else {
            div.slideUp(600, function() { div.empty(); });
        }
    };
};

response.render = function(context, json, type, key, idx) {
    var name = key;
    if (typeof idx === 'number') { name += sprintf('[%s]', idx); }
    name = context.makeLink(key, json, name);

    var head = $('<div class="head">');
    head.append($('<div class="name">').html(name));
    head.append($('<div class="summary">').html(summary.run(context, type, json)));
    var button = $('<div class="button">');
    if (extended.hasExtended(context, type, json)) {
        button.append(
            response.makeObjectButton(
                'Ext',
                response.makeObjectButtonHandle('div.extended', function() {
                    return extended.run(context, type, json);
                })
            )
        );
    }
    if (map.hasMap(context, type, json)) {
        button.append(
            response.makeObjectButton(
                'Map',
                response.makeObjectButtonHandle('div.map', function() {
                    return map.run(context, type, json);
                })
            )
        );
    }
    button.append(
        response.makeObjectButton(
            '{ }',
            response.makeObjectButtonHandle('div.code', function() {
                return renderjson(json);
            })
        )
    );
    head.append(button);

    var data = $('<div class="data">')
        .append($('<div class="extended">').hide())
        .append($('<div class="map">').hide())
        .append($('<div class="code">').hide());

    var result = $('<div class="object">');
    result.append(head);
    result.append(data);
    return result;
};

response.Context = function(data) {
    // the token, used to create links
    var token = URI(window.location).search(true).token;

    // the regex corresponding to the thing that should be replacced
    // in a templated link
    var templateRegex = /\{.*\.id\}/;

    // the link map: type -> template
    this.links = {};
    if (data instanceof Object && 'links' in data && $.isArray(data.links)) {
        var self = this;
        data.links.forEach(function(link) {
            if (! link.templated) { return; }
            if (link.type === 'related') { return; }
            if (! link.href.match(templateRegex)) { return; }
            self.links[utils.getType(link.type)] = link.href;
        });
    }

    this.makeHref = function(href) {
        var res = sprintf('?request=%s', encodeURIComponent(href));
        if (token) {
            res += sprintf('&token=%s', encodeURIComponent(token));
        }
        return res;
    };

    this.makeLink = function(k, obj, name) {
        var key = utils.getType(k);
        if (typeof name === 'string') { name = utils.htmlEncode(name); }
        if (! (key in this.links) || ! ('id' in obj)) {
            return $('<span/>').html(name);
        }
        var href = this.links[key].replace(templateRegex, obj.id);
        return $('<a>').attr('href', this.makeHref(href)).html(name);
    };

    var minDurationColor = {};
    if (data instanceof Object && 'isochrones' in data && $.isArray(data.isochrones)) {
        var min_duration = data.isochrones.map(function(isochrone) { return isochrone.min_duration; });
        var max_isochrone = data.isochrones.length;
        var scale = max_isochrone > 1 ? max_isochrone - 1 : 1;
        for (var i = 0; i < max_isochrone; i ++) {
            var ratio = i / scale;
            minDurationColor[min_duration[i]] = utils.computeColorFromRatio(ratio);
        }
    }
    this.getColorFromMinDuration = function(minDuration, alpha) {
        var color = minDurationColor[minDuration] || {red: 0, green: 0, blue: 0};
        return utils.toCssColor(color, alpha);
    };
};

response.manageFile = function() {
    function readSingleFile(event) {
        event.preventDefault();
        event.stopPropagation();
        var files = event.target.files || event.originalEvent.dataTransfer.files;
        if (!files || !files[0]) { return; }
        var file = files[0];
        var reader = new FileReader();
        reader.onload = function(event) {
            try {
                var data = JSON.parse(event.target.result);
                $('#status').text(sprintf('Status: file "%s" loaded', file.name));
                $('#data').html(response.render(new response.Context(data), data, 'response', 'response'));
                $('#data input').first().click();
            } catch (e) {
                $('#status').text(
                    sprintf('Status: error while loading file "%s": %s', file.name, e)
                );
            }
        };
        reader.readAsText(file);
        $('#file-input').val(null);// be sure to have next change
    }

    $('#file-input').change(readSingleFile);
    $(document)
        .on('dragover', false)
        .on('dragleave', false)
        .on('drop', readSingleFile);
};

response.manageUrl = function() {
    var req = request.parseUrl();
    if (req === null) {
        $('#status').html('Status: no request');
        return;
    }
    var start_time = new Date().getTime();
    $.ajax({
        headers: utils.manageToken(req.token),
        url: req.request,
        dataType: 'json',
    }).then(
        function(data, status, xhr) {
            response.setStatus(xhr.statusText, xhr.status, start_time);
            $('#data').html(response.render(new response.Context(data), data, 'response', 'response'));
            $('#data input').first().addClass('noAnimation');
            $('#data input').first().click();
            $('html, body').animate({ scrollTop: $('#response').offset().top }, 600);
            if (! storage.getToken(req.api)) {
                storage.saveToken(req.api, req.token);
            }
            // update the drop list of autocompletion for API
            autocomplete.apiAutocomplete();
        },
        function(xhr, status, error) {
            response.setStatus(utils.errorMessage(req.request, xhr, status, error),
                               xhr.status,
                               start_time);
            $('#data').html(response.render(new response.Context(xhr.responseJSON), xhr.responseJSON, 'response', 'response'));
            $('#data input').last().click();
            utils.notifyOnError('Response', req.request, xhr, status, error);
        }
    );
};

// renderjson config
$(document).ready(function() {
    renderjson.set_show_to_level(1);
    renderjson.set_max_string_length(60);
    renderjson.set_sort_objects(true);
});

// Copyright (c) 2016 CanalTP
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

'use strict';

// fake includes
var request;

var storage = {};

storage._storagePrefix = 'navitia-playground.';
storage._apiStoragePrefix = storage._storagePrefix + 'api.';
storage._layerStorageKey = storage._storagePrefix + 'layer';

storage._localStorageAvailable = function() {
    try {
	var x = '__storage_test__';
	window.localStorage.setItem(x, x);
	window.localStorage.removeItem(x);
        storage._upgrade();
	return true;
    }
    catch(e) {
	return false;
    }
};

// TODO: remove this upgrade in 2017
storage._oldApiStoragePrefix = 'navitiaPlayground.';
storage._upgrade = function() {
    for (var elt in window.localStorage) {
        if (elt.indexOf(storage._oldApiStoragePrefix) === 0 ) {
            window.localStorage.setItem(
                storage._apiStoragePrefix + elt.slice(storage._oldApiStoragePrefix.length),
                window.localStorage[elt]);
            window.localStorage.removeItem(elt);
        }
    }
};

storage.getApis = function() {
    if (! storage._localStorageAvailable()) { return []; }
    var apis = [];
    for (var elt in window.localStorage) {
        if (elt.indexOf(storage._apiStoragePrefix) === 0 ) {
            apis.push(elt.slice(storage._apiStoragePrefix.length));
        }
    }
    return apis;
};

storage.saveTokenFromRequest = function() {
    var api = $('input.api').val();
    var token = $('input.token').val();
    storage.saveToken(api, token);
};

storage.saveToken = function(api, token) {
    if (! storage._localStorageAvailable()) { return; }
    var key = storage._apiStoragePrefix + api;
    window.localStorage.setItem(key, token);
    request.setSaveTokenButtonStatus();
};

storage.getToken = function(api) {
    if (! storage._localStorageAvailable()) { return; }
    return window.localStorage.getItem(storage._apiStoragePrefix + api);
};

storage.saveLayer = function(data) {
    if (! storage._localStorageAvailable()) { return; }
    window.localStorage.setItem(storage._layerStorageKey, data.name);
};

storage.getLayer = function() {
    if (! storage._localStorageAvailable()) { return null; }
    return window.localStorage.getItem(storage._layerStorageKey);
};

// Copyright (c) 2016 CanalTP
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

'use strict';

// fake includes
var response;
var modes;
var utils;

var summary = {};

summary.make = {};

summary.make.response = function(context, json) {
    if (! json) {
        return 'Error: response is not JSon';
    }
    if ('message' in json) {
        return sprintf('Message: %s', json.message);
    }
    if ('error' in json && json.error && 'message' in json.error) {
        return sprintf('Error: %s', json.error.message);
    }
    var result = '';
    var key = response.responseCollectionName(json);
    if (key) {
        result = result + sprintf(' %s %s ', json[key].length, key);
    }
    if ('pagination' in json) {
        var p = json.pagination;
        var first_number = p.start_page * p.items_per_page + 1;
        result = result + sprintf('(%s-%s of %s results)',
            first_number,
            first_number + p.items_on_page - 1,
            p.total_result);
    }
    return result;
};

summary.make.journey = function(context, json) {
    var res = $('<span>').append(summary.formatTime(json.departure_date_time));
    function add(s) {
        res.append(' > ');
        $('<span/>').addClass('mode-and-code').append(s).appendTo(res);
    }

    if ('sections' in json) {
        var first_section_mode = null;
        var last_section_mode = null;
        json.sections.forEach(function(s) {
            switch (s.type) {
            case 'public_transport':
            case 'on_demand_transport':
                if (! first_section_mode) {
                    first_section_mode = last_section_mode;
                }
                last_section_mode = null;
                break;
            case 'street_network':
                switch (s.mode) {
                case 'bike': last_section_mode = 'bike'; break;
                case 'car': last_section_mode = 'car'; break;
                case 'walking':
                    if (! last_section_mode) { last_section_mode = 'walking'; }
                    break;
                }
                break;
            case 'bss_rent':
            case 'bss_put_back':
                last_section_mode = 'bss';
                break;
            }
        });

        if (first_section_mode) {
            add(modes.makeSnPicto(first_section_mode));
        }
        var stayIn = false;
        json.sections.forEach(function(s) {
            if (s.type === 'transfer' && s.transfer_type === 'stay_in') {
                stayIn = true;
            }
            if ($.inArray(s.type, ['public_transport', 'on_demand_transport']) === -1) { return; }
            if (stayIn) {
                res.append('&thinsp;').append(summary.makeLineCode(s.display_informations));
                stayIn = false;
            } else {
                add(summary.makePhysicalModesFromSection(s)
                    .append(summary.makeLineCode(s.display_informations)));
            }
        });
        if (last_section_mode) {
            add(modes.makeSnPicto(last_section_mode));
        }
    } else {
        // isochron
        add(summary.run(context, 'place', json.from));
        add(sprintf('%s transfer(s)', json.nb_transfers));
        add(summary.run(context, 'place', json.to));
    }
    add(summary.formatTime(json.arrival_date_time));

    if ('durations' in json) {
        if (json.durations.total) {
            $('<span/>')
                .addClass('section-additional-block')
                .append($('<img>').addClass('picto').attr('src', 'img/duration.svg'))
                .append(' ' + utils.durationToString(json.durations.total))
                .appendTo(res);
        }
        if (json.durations.walking) {
            $('<span/>')
                .addClass('section-additional-block')
                .append(modes.makeSnPicto('walking'))
                .append(utils.durationToString(json.durations.walking))
                .appendTo(res);
        }
    }

    if (json.status) {
        $('<span/>')
            .addClass('section-additional-block')
            .append('status: ' + utils.htmlEncode(json.status))
            .appendTo(res);
    }

    return res;
};

summary.make.isochrone = function(context, json) {
    var res = $('<span>');
    if ('from' in json) {
      res.append(sprintf('from %s, ', utils.htmlEncode(json.from.name)));
    }
    if ('to' in json) {
      res.append(sprintf('to %s, ', utils.htmlEncode(json.to.name)));
    }
    if ('min_duration' in json && 'max_duration' in json) {
        $('<span/>')
            .addClass('with-bg-color')
            .css('background-color', context.getColorFromMinDuration(json.min_duration, 0.25))
            .text(sprintf('duration: [%s, %s]',
                          utils.durationToString(json.min_duration),
                          utils.durationToString(json.max_duration)))
            .appendTo(res);
    } else {
        res.text('no summary');
    }
    return res;
};

summary.make.heat_map = function(context, json) {
    var res = $('<span>');
    if ('from' in json) {
      res.append(sprintf('from %s, ', utils.htmlEncode(json.from.name)));
    } else if ('to' in json) {
      res.append(sprintf('to %s, ', utils.htmlEncode(json.to.name)));
    } else {
        res.text('no summary');
    }
    return res;
};

summary.make.links = function(context, json) {
    var res = $('<span>');
    function makeData(link) {
        if (link.templated) {
            return sprintf('{%s}', link.type);
        }
        return link.type;
    }
    if ($.isArray(json)) {
        json.forEach(function(link) {
            res.append(' ');
            if (link.id) {
                context.makeLink(link.type, link, link.type).appendTo(res);
            } else {
                $('<a>')
                    .attr('href', context.makeHref(link.href))
                    .text(makeData(link))
                    .appendTo(res);
            }
        });
    } else {
        res.append('Links is not an array!');
    }
    return res;
};

summary.make.codes = function(context, json) {
    var text = json.map(function(code) {
        return sprintf('%s: %s', code.type, code.value);
    }).join(', ');
    return $('<span>').text(text);
};

summary.make.warning = function(context, json) {
    return $('<span>').text(json.message);
};

summary.make.pt_object = summary.make.place = function(context, json) {
    var res = $('<span>')
        .text(json.embedded_type)
        .append(': ')
        .append(summary.run(context, json.embedded_type, json[json.embedded_type]));
    if ('distance' in json) {
        res.append(sprintf(' at %dm', json.distance));
    }
    return res;
};

summary.make.table = function(context, json) {
    return $('<span>').text(sprintf('%d vehicle journeys, %d stop points',
                                    json.headers.length,
                                    json.rows.length));
};

summary.make.section = function(context, section) {
    var res = $('<span>');
    var pt = false;

    switch (section.type) {
    case 'street_network': res.append(modes.makeSnPicto(section.mode)); break;
    case 'bss_rent':
        res.append(modes.makeSnPicto('bss')).append(' rent');
        break;
    case 'bss_put_back':
        res.append(modes.makeSnPicto('bss')).append(' put back');
        break;
    case 'leave_parking':
        res.append(modes.makeSnPicto('car')).append(' leave parking');
        break;
    case 'transfer':
        if (section.transfer_type === 'walking') {
            res.append(modes.makeSnPicto('walking'));
        } else {
            res.append(document.createTextNode(section.transfer_type));
        }
        break;
    case 'on_demand_transport':
        res.append(section.type + ' ');
        pt = true;
        res.append(summary.makeRoutePoint(context, section));
        break;
    case 'public_transport':
        pt = true;
        res.append(summary.makeRoutePoint(context, section));
        break;
    default: res.append(section.type); break;
    }

    if ('from' in section) {
        res.append(sprintf(' from %s', utils.htmlEncode(section.from.name)));
    }
    if (pt) {
        res.append(summary.makeSectionTime(section.departure_date_time,
                                           section.base_departure_date_time));
    }
    if ('to' in section) {
        res.append(sprintf(' to %s', utils.htmlEncode(section.to.name)));
    }
    if (pt) {
        res.append(summary.makeSectionTime(section.arrival_date_time,
                                           section.base_arrival_date_time));
    }
    if ('duration' in section) {
        res.append(sprintf(' during %s', utils.durationToString(section.duration)));
    }
    return res;
};

summary.make.region = function(context, region) {
    function makeDate(d) {
        if (typeof d !== 'string') { return null; }
        var year = + d.slice(0, 4);
        var month = + d.slice(4, 6) - 1;
        var day = + d.slice(6, 8);
        return new Date(year, month, day);
    }
    function formatDate(d) {
        if (!(d instanceof Date)) { return '???'; }
        return sprintf('%04d-%02d-%02d', d.getFullYear(), d.getMonth() + 1, d.getDate());
    }
    var res = $('<span/>').text(region.id + (region.name ? sprintf(' (%s)', region.name) : ''));
    var now = new Date();
    var begin = makeDate(region.start_production_date);
    var end = makeDate(region.end_production_date);
    var remaining_days = Math.round((end - now) / 1000 / 60 / 60 / 24);
    if (region.error && region.error.value) {
        res.append(sprintf(', <span class="error">error: %s</span>', utils.htmlEncode(region.error.value)));
    } else if (region.status !== 'running') {
        res.append(sprintf(', <span class="error">status: %s</span>', utils.htmlEncode(region.status)));
    } else if (now < begin || end < now) {
        res.append(sprintf(', <span class="outofdate">out-of-date [%s, %s]</span>',
                           formatDate(begin),
                           formatDate(end)));
    } else if (remaining_days <= 21) {
        res.append(sprintf(', <span class="almost_outofdate">%sd remaining</span>', remaining_days));
    }
    return res;
};

summary.make.line = function(context, line) {
    var code = $('');
    if (line.code) {
        code = $('<span>')
            .addClass('with-bg-color')
            .append(line.code);
        summary.setColors(code, line);
    }
    return $('<span>')
        .append(modes.makePtPicto(line.physical_modes))
        .append(code)
        .append(' ')
        .append(document.createTextNode(line.name));
};

summary.make.stop_date_time = function(context, stop_time) {
    var sum = summary.run(context, 'stop_point', stop_time.stop_point);
    var res = $('<span>')
        .append(summary.makeImpactedTime(stop_time.arrival_date_time,
                                         stop_time.base_arrival_date_time))
        .append(' > ')
        .append(summary.makeImpactedTime(stop_time.departure_date_time,
                                         stop_time.base_departure_date_time))
        .append(' ')
        .append(sum);
    return res;
};

summary.make.departure = function(context, json) {
    var res = $('<span>');
    res.append(summary.makeImpactedTime(json.stop_date_time.departure_date_time,
                                        json.stop_date_time.base_departure_date_time));
    res.append(': ');
    res.append(summary.makeRoutePoint(context, json));
    res.append(' (' + json.stop_date_time.data_freshness + ')');
    return res;
};

summary.make.arrival = function(context, json) {
    var res = $('<span>');
    res.append(summary.makeImpactedTime(json.stop_date_time.arrival_date_time,
                                        json.stop_date_time.base_arrival_date_time));
    res.append(': ');
    res.append(summary.makeRoutePoint(context, json));
    res.append(' (' + json.stop_date_time.data_freshness + ')');
    return res;
};

summary.make.stop_schedule = function(context, json) {
    return summary.makeRoutePoint(context, json);
};

summary.make.date_time = function(context, json) {
    var res = $('<span>');
    res.append(summary.formatTime(json.date_time));
    res.append(' (' + json.data_freshness + ')');
    return res;
};

summary.make.route_schedule = function(context, json) {
    return summary.makeRoutePoint(context, json);
};

summary.make.physical_mode = function(context, json) {
    return $('<span/>')
        .append(modes.makePtPicto(json))
        .append(document.createTextNode(' ' + json.name));
};

summary.make.connection = function(context, json) {
    return $('<span/>').text(sprintf('%s > %s, duration: %s, display_duration: %s',
                                     json.origin.id,
                                     json.destination.id,
                                     utils.durationToString(json.duration),
                                     utils.durationToString(json.display_duration)));
};

summary.make.tags = function(context, json) {
    return $('<span/>').text(json.join(', '));
};

summary.make.contributor = function(context, json) {
    var res = $('<span/>');
    var url = json.url ? json.url : json.website;
    if (url && typeof url === 'string') {
        if (url.indexOf('://') === -1) { url = 'http://' + url; }
        res.append($('<a/>').attr('href', url).text(json.name));
    } else {
        res.text(json.name);
    }
    if (json.license) {
        res.append(', license: ' + utils.htmlEncode(json.license));
    }
    return res;
};

summary.make.dataset = function(context, json) {
    return $('<span/>').text(sprintf('%s (%s - %s): [%s, %s]',
        json.description,
        json.realtime_level,
        json.system,
        summary.formatDatetime(json.start_validation_date),
        summary.formatDatetime(json.end_validation_date)
    ));
};

summary.make.stands = function(context, json) {
    return  $('<span/>').text(sprintf(
        'bikes: %d, places: %d, total: %d',
        json.available_bikes,
        json.available_places,
        json.total_stands
    ));
};

summary.make.disruption = function(context, json) {
    var res = $('<span/>');
    res.append($('<span/>').css('color', json.severity.color).text(json.severity.name));
    if (json.status) { res.append(', status: ' + utils.htmlEncode(json.status)); }
    if (json.cause) { res.append(', cause: ' + utils.htmlEncode(json.cause)); }
    return res;
};

summary.make.message = function(context, json) {
    var res = $('<span/>');
    if (json.channel.content_type === 'text/html') {
        res.html(json.text);
    } else {
        res.text(json.text);
    }
    res.prepend(sprintf('%s: ', utils.htmlEncode(json.channel.name)));
    return res;
};

summary.make.application_periods = function(context, json) {
    var res = $('<span/>');
    var text = json.map(function(period) {
        return sprintf('[%s, %s]',
                       summary.formatDatetime(period.begin),
                       summary.formatDatetime(period.end));
    }).join(' ∪ ');
    res.text(text);
    return res;
};

summary.make.impacted_object = function(context, json) {
    return summary.run(context, 'pt_object', json.pt_object);
};

summary.make.impacted_stop = function(context, json) {
    var res = $('<span>');
    res.append(summary.run(context, 'stop_point', json.stop_point));
    res.append(': ');
    res.append(summary.makeImpactedTime(json.amended_arrival_time, json.base_arrival_time));
    res.append(' > ');
    res.append(summary.makeImpactedTime(json.amended_departure_time, json.base_departure_time));
    if (json.cause) { res.append(utils.htmlEncode(', cause: ' + json.cause)); }
    return res;
};

summary.make.co2_emission = function(context, json) {
    return $('<span/>').html(sprintf('CO<sub>2</sub>:&nbsp;%s&nbsp;%s', json.value, json.unit));
};

// add your summary view by adding:
//   summary.make.{type} = function(context, json) { ... }

summary.setColors = function(elt, json) {
    if ('color' in json) {
        elt.css('background-color', '#' + json.color);
        elt.css('color', utils.getTextColor(json));
    }
};

summary.defaultSummary = function(context, type, json) {
    if (! (json instanceof Object)) { return 'Invalid object'; }

    var res = $('<span/>');
    if ('physical_modes' in json && $.isArray(json.physical_modes)) {
        json.physical_modes.forEach(function(mode) {
            res.append(modes.makePtPicto(mode));
        });
    }
    if ('label' in json) {
        res.append(document.createTextNode(json.label));
    } else if ('name' in json) {
        res.append(document.createTextNode(json.name));
    } else if ('id' in json) {
        res.append(document.createTextNode(json.id));
    } else {
        res.append('no summary');
    }
    return res;
};

summary.formatDatetime = function(datetime) {
    var formated = datetime.replace(/(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})/,
                                    '$1-$2-$3 $4:$5:$6');
    if (formated.slice(-2) === '00') {
        return formated.slice(0, -3);
    } else {
        return formated;
    }
};

summary.formatTime = function(datetime) {
    if (datetime.length === 6) {
        var formated = datetime.replace(/(\d{2})(\d{2})(\d{2})/, '$1:$2:$3');
        if (formated.slice(-2) === '00') {
            return formated.slice(0, -3);
        } else {
            return formated;
        }
    }
    return summary.formatDatetime(datetime).split(' ')[1];
};

summary.makeSectionTime = function(dt, baseDt) {
    var res = $('<span/>');
    res.append(' at ');
    if (baseDt && baseDt !== dt) {
        res.append($('<span/>').addClass('old-datetime').text(summary.formatTime(baseDt)));
    }
    res.append(sprintf(' %s', summary.formatTime(dt)));
    return res;
};

summary.makeImpactedTime = function(amended, base) {
    var res = $('<span/>');
    if (base && base !== amended) {
        res.append($('<span/>').addClass('old-datetime').text(summary.formatTime(base)));
        res.append(' ');
    }
    res.append(utils.htmlEncode(summary.formatTime(amended)));
    return res;
};

summary.makePhysicalModesFromSection = function(section) {
    if ('links' in section) {
        var pms = section.links
            .map(function(o) {
                if (o.type === 'physical_mode') {
                    return { id: o.id, name: section.display_informations.physical_mode };
                } else {
                    return null;
                }
            });
        return modes.makePtPicto(pms);
    }
};

summary.makeLineCode = function(display_informations) {
    if (! display_informations.code) { return $(''); }
    var elt = $('<span>')
        .addClass('with-bg-color')
        .append(display_informations.code);
    summary.setColors(elt, display_informations);
    return elt;
};

summary.makeRoutePoint = function(context, json) {
    var res = $('<span/>');
    if ('route' in json) {
        res.append(modes.makePtPicto(json.route.physical_modes));
    } else if ('links' in json && 'display_informations' in json) {
        res.append(summary.makePhysicalModesFromSection(json));
    }
    res.append(summary.makeLineCode(json.display_informations));
    res.append(' > ');
    res.append(json.display_informations.direction);
    if (json.stop_point) {
        res.append(' at ');
        res.append(summary.run(context, 'stop_point', json.stop_point));
    }
    return res;
};

summary.run = function(context, type, json) {
    var res;
    try {
        if (type in summary.make) {
            res = summary.make[type](context, json);
        } else {
            res = summary.defaultSummary(context, type, json);
        }
    } catch (e) {
        console.log(sprintf('summary(%s) thows an exception:', type));// jshint ignore:line
        console.log(e);// jshint ignore:line
        res = 'summary error';
    }
    if (res instanceof jQuery) {
        return res.get(0);
    } else if (typeof res === 'string') {
        return $('<span>').text(res).get(0);
    }
    return res;
};

// Copyright (c) 2016 CanalTP
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

'use strict';

// fake includes
var summary;
var response;

var utils = {};

utils.isDatetimeType = function(str) {
    return $.inArray(str, ['since', 'until']) !== -1 || str.match(/datetime$/);
};

utils.htmlEncode = function(value) {
    return $('<div/>').text(value).html();
};

utils.durationToString = function(duration) {
    var res = '';
    var seconds = duration % 60;
    var minutes = Math.floor(duration / 60) % 60;
    var hours = Math.floor(duration / (60 * 60)) % 24;
    var days = Math.floor(duration / (24 * 60 * 60));

    if (days !== 0) { res += sprintf('%sd', days); }
    if (hours !== 0) { res += sprintf('%sh', hours); }
    if (minutes !== 0) { res += sprintf('%smin', minutes); }
    if (seconds !== 0) { res += sprintf('%ss', seconds); }

    if (! res) {
        return '0s';
    } else {
        return res;
    }
};

utils.isTemplate = function(str) {
    return str.slice(0, 1) === '{' && str.slice(-1) === '}';
};

utils.flatMap = function(array, f) {
    var result = [];

    array.forEach(function(obj, i, array) {
        result = result.concat(f(obj, i, array));
    });
    return result;
};

$.notify.addStyle('navitia', {
    html: '<div class="ui-widget"><span data-notify-html="text"></span></div>',
    classes: {
        error: {
            'color': '#B94A48',
            'background-color': '#F2DEDE',
            'border-color': '#EED3D7',
        },
        success: {
            'color': '#468847',
            'background-color': '#DFF0D8',
            'border-color': '#D6E9C6',
        },
        info: {
            'color': '#3A87AD',
            'background-color': '#D9EDF7',
            'border-color': '#BCE8F1',
        },
        warn: {
            'color': '#C09853',
            'background-color': '#FCF8E3',
            'border-color': '#FBEED5',
        }
    }
});

utils.errorMessage = function(url, xhr, status/*, error*/) {
    var message;
    if (url.startsWith('http:') && window.location.protocol === 'https:') {
        message = $('<span>').text(
            'You cannot request the API using http if ' +
                'you are connected to navitia-playground ' +
                'using https.  Please request the API using ' +
                'https or connect to navitia-playground ' +
                'using http.');
    } else if (xhr.readyState === 0) {
        message = $('<span>').text('Network error');
    } else if (xhr.responseJSON) {
        message = $(summary.run(new response.Context(xhr.responseJSON),
                                'response',
                                xhr.responseJSON));
    } else {
        message = $('<span>').text(status);
    }
    return message;
};

utils.notifyOnError = function(typeError, url, xhr, status, error) {
    if (xhr.status === 401) {
        $('#token').addClass('templateInput');
    }
    var message = utils.errorMessage(url, xhr, status, error);
    $.notify({
        text: $('<span/>').text(sprintf('%s error: ', typeError)).append(message)
    }, {
        position: 'right bottom',
        style: 'navitia',
    });
};

utils.notifyWarn = function(message) {
    $.notify({
        text: message
    }, {
        position: 'right bottom',
        className: 'warn',
        style: 'navitia',
    });
};

utils.getType = function(key) {
    if (!key || typeof key !== 'string') {
        return null;
    }
    // hardcoded cases:
    switch (key) {
    case 'places_nearby': return 'place';
    case 'addresses': return 'address';
    case 'from': return 'place';
    case 'to': return 'place';
    }
    // generic plural
    if (key.slice(-1) === 's') { return key.slice(0, -1); }

    // just the key
    return key;
};

utils.getTextColor = function(json) {
    function _toNum(c, i) { return +('0x' + c.slice(i, i + 2)); }

    if (json.text_color) {
        return '#' + json.text_color;
    }
    if (json.color) {
        var c = json.color;
        var grey = 0.21 * _toNum(c, 0) + 0.72 * _toNum(c, 2) + 0.07 * _toNum(c, 4);
        if (grey < 128) {
            return 'white';
        }
    }
    return 'black';
};

utils.computeColorFromRatio = function(ratio) {
    var r = 255;
    var g = 255;
    if (ratio < 1/2) {
        r = Math.ceil(255 * ratio * 2);
    } else {
        g = Math.ceil(255 * (1 - ratio) * 2);
    }
    return {red: r, green: g, blue: 0};
};

utils.toCssColor = function(c, alpha) {
    if (alpha) {
        return sprintf('rgba(%s, %s, %s, %s)', c.red, c.green, c.blue, alpha);
    } else {
        return sprintf('#%02x%02x%02x', c.red, c.green, c.blue);
    }
};

utils.getColorFromRatio = function(ratio) {
    return utils.toCssColor(utils.computeColorFromRatio(ratio));
};

utils.manageToken = function(token) {
  return token ? { Authorization: 'Basic ' + btoa(token) } : {};
};
